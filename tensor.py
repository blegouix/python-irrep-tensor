# SPDX-FileCopyrightText: 2024 Baptiste Legouix
# SPDX-License-Identifier: GPL-3.0

import numpy as np

from csr import *
from fill import *
from hamming_weight_binary_code import *

# General Tensor class with internal symmetries
class Tensor:
    m_r = 0
    m_d = 0
    m_irrep_dim = 0
    m_U = Csr((0,)) 
    m_V = Csr((0,)) 
    m_data = np.empty(0) 

    # Gram-shmidt approach to produce from vec an orthogonal vector to the vector space generated by basis
    def orthogonalize(self, vec, basis):
        for i in range(0,basis.m_ndims[0]):
            eigentensor = csr2dense(basis.get(i, axis=0)).reshape(tuple([self.m_d for i in range(0, self.m_r)]))
            vec = vec - np.tensordot(vec, eigentensor, axes=self.m_r)/np.tensordot(eigentensor, eigentensor, axes=self.m_r)*eigentensor
        return vec

    # Build orthonormal basis for the eigen subspace associated to the eigenvalue 1 of the projection operator
    def orthonormal_basis_subspace_eigenvalue_1(self, Proj):
        U = Csr(((0,)+tuple([self.m_d for i in range(0, self.m_r)]))); 
        V = Csr(((0,)+tuple([self.m_d for i in range(0, self.m_r)]))); 

        index = 0;
        while V.m_ndims[0]<self.m_irrep_dim:
            index = index+1;
            candidate = np.zeros(tuple([self.m_d for i in range(0, self.m_r)]))
            def candidate_lambda(T, idx):
                T[idx] = nth_binary_by_hamming_weight(index, self.m_d**self.m_r)//2**int(np.sum([self.m_d**i*idx[i] for i in range(0,len(idx))]))%2
            fill(candidate, (), candidate_lambda)
            candidate = np.tensordot(Proj, np.random.randint(2, size=tuple([self.m_d for i in range(0, self.m_r)])), axes=self.m_r);
            v = self.orthogonalize(np.tensordot(Proj, candidate, axes=self.m_r), V);

            if np.any(v>0.25):
                v = v/np.sqrt(np.tensordot(v, v, axes=self.m_r)) # normalize
                # u = np.tensordot(np.tensordot(Tr, Proj, axis=self.n_r), v, axis=self.n_r) # not sure if this or u = v is correct
                u = v
                U.append_dense(u.reshape(tuple([self.m_d for i in range(0, self.m_r)])), axis=0)
                V.append_dense(v.reshape(tuple([self.m_d for i in range(0, self.m_r)])), axis=0)
        return [U, V] 

    def __init__(self, young_tableau):
        # TODO: assert Proj hypercubic and pair rank
        self.m_r = young_tableau.m_r 
        self.m_d = young_tableau.m_d
        self.m_irrep_dim = young_tableau.irrep_dim()
        [self.m_U, self.m_V] = self.orthonormal_basis_subspace_eigenvalue_1(young_tableau.projector())

    def __call__(self):
        return self.m_V.mult(self.m_data, operate_on="left") 

    def set(self, x):
        self.m_data = self.m_U.mult(x, operate_on="right")
