import numpy as np

d = 4 # dimension

class Coo:
    m_ndims = np.empty(0) 
    m_idx = np.empty(0) 
    m_values = np.empty(0)

    def __init__(self, ndims):
        self.m_ndims = np.array(ndims) 
        self.m_idx = np.empty((len(ndims), 0))
        self.m_values = np.empty(0)
    
    def append_dense(self, dense, **kwargs):
        idx = np.nonzero(dense)
        self.m_values = np.append(self.m_values, dense[idx])
        idx = np.array(idx)
        for i in range(0, idx.shape[1]):
            idx[kwargs.get('axis', None), i] = self.m_ndims[kwargs.get('axis', None)]
        self.m_ndims[kwargs.get('axis', None)] = self.m_ndims[kwargs.get('axis', None)]+1
        self.m_idx = np.append(self.m_idx, idx, 1)

def coo2dense(coo):
    dense = np.zeros(coo.m_ndims);
    for i in range(0, np.size(coo.m_values)):
        dense[tuple([int(coo.m_idx[j, i]) for j in range(0,len(coo.m_ndims))])] = coo.m_values[i]
    return dense

# Create rank-2 identity operator
I = np.zeros((d, d, d, d))

for i in range(0,d):
    for j in range(0,d):
        for k in range(0,d):
            for l in range(0,d):
                if i==k and j==l:
                    I[i,j,k,l] = 1

# Create rank-2 transpose operator
Tr = np.zeros((d, d, d, d))

for i in range(0,d):
    for j in range(0,d):
        for k in range(0,d):
            for l in range(0,d):
                if i==l and j==k:
                    Tr[i,j,k,l] = 1
# Create symmetric projection
Sym = (Tr+I)/2

# Create antisymmetric projection
AntiSym = (Tr-I)/2

# Gram-shmidt approach to produce from vec an orthogonal vector to the vector space generated by basis
def orthogonalize(vec, basis):
    basis = coo2dense(basis)
    for i in range(0,basis.shape[-1]):
        vec = vec - np.tensordot(vec, basis[:,:,i].reshape(d,d))/np.tensordot(basis[:,:,i].reshape(d,d), basis[:,:,i].reshape(d,d))*basis[:,:,i].reshape(d,d)
    return vec

# Build orthonormal basis for the eigen subspace associated to the eigenvalue 1 of the projection operator
def orthonormal_basis_subspace_eigenvalue_1(Proj):
    U = Coo((0,d,d)); 
    V = Coo((d,d,0)); 

    index = 0;
    # while np.size(V, axis=2)<d*(d+1)//2:
    while V.m_ndims[2]<d*(d-1)//2:
        index = index+1;
        candidate = np.zeros((d, d))
        for i in range(0,d):
            for j in range(0,d):
                candidate[i,j] = index//2**(i*d+j)%2
        # candidate = np.tensordot(Proj, np.random.randint(2, size=(d,d)));
        v = orthogonalize(np.tensordot(Proj, candidate), V);

        if np.any(v>0.25):
            v = v/np.sqrt(np.tensordot(v, v)) # normalize
            u = np.tensordot(np.tensordot(Tr, Proj), v) # not sure if this or u = v is correct
            # u = v 
            U.append_dense(u.reshape(1,d,d), axis=0)
            V.append_dense(v.reshape(d,d,1), axis=2)
    return [U, V] 

#test
test = np.empty((d,d))

for i in range(0,d):
    for j in range(0,d):
        test[i,j] = j-i
print(test)

[U, V] = orthonormal_basis_subspace_eigenvalue_1(AntiSym)
print(U.m_idx)
print(U.m_values)
compressed_test = np.tensordot(coo2dense(U), test, axes=2)
uncompressed_test  = np.tensordot(coo2dense(V), compressed_test, axes=1)
print(np.all(abs(uncompressed_test-test)<1e-14))
